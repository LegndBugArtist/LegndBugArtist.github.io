<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术 on Home</title>
    <link>https://emuci.top/categories/%E6%8A%80%E6%9C%AF/</link>
    <description>Recent content in 技术 on Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 27 Sep 2021 14:44:00 +0800</lastBuildDate><atom:link href="https://emuci.top/categories/%E6%8A%80%E6%9C%AF/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>SwiftUI入门笔记3:属性包装propertyWrapper</title>
      <link>https://emuci.top/posts/swiftui-%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85propertywrapper/</link>
      <pubDate>Mon, 27 Sep 2021 14:44:00 +0800</pubDate>
      
      <guid>https://emuci.top/posts/swiftui-%E5%B1%9E%E6%80%A7%E5%8C%85%E8%A3%85propertywrapper/</guid>
      <description>在 Swift 中，这一特性的正式名称是属性包装 (Property Wrapper)。不论是 @State，@Binding，或者是我们在下一节中将要看到的 @ObjectBinding 和 @EnvironmentObject，它们都是被 @propertyWrapper 修饰的 struct 类型。以 State 为例，在 SwiftUI 中 State 定义的关键部分如下：
@propertyWrapper public struct State&amp;lt;Value&amp;gt; : DynamicViewProperty, BindingConvertible { public init(initialValue value: Value) public var value: Value { get nonmutating set } public var wrappedValue: Value { get nonmutating set } public var projectedValue: Binding&amp;lt;Value&amp;gt; { get } } //init(initialValue:)，wrappedValue 和 projectedValue 构成了一个 propertyWrapper 最重要的部分。在 @State 的实际使用里： struct ContentView : View { // 1 @State private var brain: CalculatorBrain = .</description>
    </item>
    
    <item>
      <title>SwiftUI入门笔记2:@State、@Binding</title>
      <link>https://emuci.top/posts/swiftui2/</link>
      <pubDate>Mon, 27 Sep 2021 14:36:36 +0800</pubDate>
      
      <guid>https://emuci.top/posts/swiftui2/</guid>
      <description>简单理解，@State是声明一个变量，@Binding是引用一个变量
@State 属性值只能在属性本身被设置时触发 UI 刷新，这个特性让它非常适合用来声明一个值类型的值：因为对值类型的属性的变更，也会触发整个值的重新设置，进而刷新 UI。不过，在把这样的值在不同对象间传递时，状态值将会遵守值语义发生复制。
所以，即使我们将 ContentView 里的 brain 通过参数的方式层层向下，传递给 CalculatorButtonPad 和 CalculatorButtonRow，最后在按钮事件中，因为各个层级中的 brain 都不相同，按钮事件对 brain 的变更也只会作用在同层级中，无法对 ContentView 中的 brain 进行改变，因此顶层的 Text 无法更新。
@Binding 就是用来解决这个问题的。和 @State 类似，@Binding 也是对属性的修饰，它做的事情是将值语义的属性“转换”为引用语义。对被声明为 @Binding 的属性进行赋值，改变的将不是属性本身，而是它的引用，这个改变将被向外传递。</description>
    </item>
    
    <item>
      <title>解决iOS相册名为英文的问题</title>
      <link>https://emuci.top/posts/%E8%A7%A3%E5%86%B3ios%E7%9B%B8%E5%86%8C%E5%90%8D%E4%B8%BA%E8%8B%B1%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 27 Sep 2021 11:14:26 +0800</pubDate>
      
      <guid>https://emuci.top/posts/%E8%A7%A3%E5%86%B3ios%E7%9B%B8%E5%86%8C%E5%90%8D%E4%B8%BA%E8%8B%B1%E6%96%87%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>在info.plist里加入下列代码即可：
&amp;lt;key&amp;gt;CFBundleAllowMixedLocalizations&amp;lt;/key&amp;gt; &amp;lt;true/&amp;gt; </description>
    </item>
    
    <item>
      <title>SwiftUI入门笔记 1</title>
      <link>https://emuci.top/posts/swiftui%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</link>
      <pubDate>Mon, 27 Sep 2021 10:26:00 +0800</pubDate>
      
      <guid>https://emuci.top/posts/swiftui%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-1/</guid>
      <description>SwiftUI在19年时发布，不支持iOS13以下系统。根据苹果官方发布数据显示，目前全部iPhone中，只有8%的设备系统低于iOS 13，而最近4年的iPhone中，只有2%低于iOS13，所以现在是时候淘汰iOS 13以下系统，使用SwiftUI开发新项目了。
重点：
 SwiftUI 的 view 是值，而非对象：它们是不可变的，用来暂时描述屏幕上应该显示什么。 我们在一个 view 上几乎所有的方法调用 (像是 frame 或 background) 都会将 view 包装在一个修饰器中。因此，这些调用的顺序很重要，这一点和 UIView 里的属性不同。 布局是自上而下的：父 view 向子 view 提供它们的可用空间，子 view 基于这个空间来决定自己的尺寸。 我们不能直接更新屏幕上的内容。相反，我们必须修改状态属性 (比如 @State 或 @ObservedObject)，然后让 SwiftUI 去找出 view 树的变化方式。  1.SwiftUI和UIKit的区别：
UIKit中创建的view或者view controller，都是长时间存在的UIView和UIViewController类的实例，然后我们修改它们的属性，来改变它们在屏幕上显示的内容。而SwiftUI中的view，是一个符合View协议的短时间存在的值，这些值描述了屏幕上应该显示的内容。这些值跟屏幕上看到的内容没有一对一的关系，view值只是暂时的，它可以随时被重新创建。
下图代码中，点击按钮，改变了counter的值以后，SwiftUI会重新计算这些view值，并更新屏幕显示内容
2.修饰器(modifier，ModifiedContent类型值)
SwiftUI 从最外层的 view 开始布局过程。ContentView 是 view 层级的根节点，布局系统会为它提供整个屏幕边界以进行布局。接下来，ContentView 把相同的尺寸提供给 VStack 让它自行布局。VStack 根据其子 view 的数量，将可用的竖直空间进行划分，并提供给每个view，如果view下面有修饰器，则会依据修饰器中包裹的条件文本标签来判断如何分配空间。
上图Button下方的.padding()就是一个修饰器，它的作用是将Text包装为一个ModifiedContent类型的值，这个值中包含有关应该如何设置 padding 填充的信息，如果在下面增加一个.background，又会把现有值包装起来创建一个新的ModifiedContent值，这一次将添加有关背景色的信息。
修饰器的顺序很重要，下面两张图，就是修饰器顺序不同出现的不同效果。第一张图实际运行时没有蓝框，这个框只是xcode标注给开发者看的，这个view的范围。
3.view更新
更改以@State、@ObservedObject 或者 @StateObject标记的属性的值，会触发view树的重新计算。
第一张截图中的counter的值被改变以后，SwiftUI 将再次访问 content view 的 body 属性，并取得对应新状态的 view 树。view树的类型在编译时就已经固定，无法改变，能改变的就是它的值，例如Text显示的文字，以及采用if语句的哪个分支。</description>
    </item>
    
  </channel>
</rss>
